{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Leopard-EM","text":"<p>Location &amp; oriEntatiOn of PARticles found using two-Dimensional tEmplate Matching (Leopard-EM) is a Python implementation of Two-Dimensional Template Matching (2DTM) using PyTorch for GPU acceleration. This package reflects most of the functionality described in Lucas, et al. (2021)<sup>1</sup> with additional user-friendly features for integrating into broader data science workflows.</p>"},{"location":"#installation","title":"Installation","text":"<p>Pre-packaged versions of Leopard-EM are released on the Python Package Index (PyPI). We target Linux operating systems on Python versions 3.9 - 3.12 for these releases, and the PyTorch GPU acceleration backend is only tested against NVIDIA GPUs. With these caveats in mind, the package can be installed using pip:</p> <pre><code>pip install leopard-em\n</code></pre> <p>We also recommend you install the package in a virtual environment (such as conda) to avoid conflicts with other installed Python packages or software on your machine. If there are persistent issues during installation, you can open up a bug report on the GitHub page.</p>"},{"location":"#installing-from-source","title":"Installing from Source","text":"<p>If you want to install Leopard-EM from source, first clone the repository and install the package using pip:</p> <pre><code>git clone https://github.com/Lucaslab-Berkeley/Leopard-EM.git\ncd Leopard-EM\npip install .\n</code></pre> <p>The <code>.</code> (period) here refers to the current working directory, and pip should parse the necessary configurations for installation.</p>"},{"location":"#for-developers","title":"For Developers","text":"<p>Developers who are interested in contributing to Leopard-EM should install the package in an editable configuration with the necessary development dependencies. After cloning the repository, navigate to the root directory of the repository and run the following command:</p> <pre><code>pip install -e '.[dev,test,docs]'\n</code></pre> <p>See the Contributing section for more information on how to contribute to the package.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Leopard-EM is most easily used by editing configuration YAML files, loading these YAML files using Python object, then running the program through a python script. There are currently 4 main programs under <code>/src/programs</code> which can be edited in-place or coped to new Python scripts on your machine:</p> <ul> <li><code>match_template.py</code>: Runs the whole orientation search a given reference template on a single cryo-EM image.</li> <li><code>refine_template.py</code>: Refines the orientation and defocus parameters for particles identified from the match template program.</li> <li><code>optimize_template.py</code>: Optimizes the pixel size of the reference temple; necessary if the pixel size of the deposited PDB model is much different from the pixel size of the micrograph.</li> <li><code>optimize_B_factor.py</code>: Optimizes the additional b-factor (blurring) applied to the template during the search.</li> </ul> <p>A minimally working Python script for running the match template program is shown below; further information on running each program can be found here: Programs</p> <pre><code>from leopard_em.pydantic_models import MatchTemplateManager\n\n# Editable parameters for the program\nYAML_CONFIG_PATH = \"/path/to/match-template-configuration.yaml\"\nDATAFRAME_OUTPUT_PATH = \"/path/to/match-template-results.csv\"\nORIENTATION_BATCH_SIZE = 32  # Tune based on GPU vram\n\n\ndef main():\n    # Load and run the match template configuration\n    mt_manager = MatchTemplateManager.from_yaml(YAML_CONFIG_PATH)\n    mt_manager.run_match_template(\n        orientation_batch_size=ORIENTATION_BATCH_SIZE,\n        do_result_export=True,  # Saves the statistics immediately upon completion\n    )\n\n    # Construct and export the dataframe of picked peaks\n    df = mt_manager.results_to_dataframe()\n    df.to_csv(DATAFRAME_OUTPUT_PATH, index=True)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#documentation-and-examples","title":"Documentation and Examples","text":"<p>Work in progress</p>"},{"location":"#theory","title":"Theory","text":"<p>Work in progress</p>"},{"location":"#api","title":"API","text":"<p>Work in progress</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We encourage contributions to this package from the broader cryo-EM/ET and structural biology communities. Leopard-EM is configured with a set of development dependencies to help contributors maintain code quality and consistency. See the Installation -- For Developers section for instructions on how to install these dependencies.</p>"},{"location":"#using-pre-commit","title":"Using <code>pre-commit</code>","text":"<p>The <code>pre-commit</code> package is used to run a set of code quality checks and auto-formatters on the codebase. If this is your first time installing the package, you will need to install the pre-commit hooks:</p> <pre><code>pre-commit install--install-hooks\n</code></pre> <p>After staging changes, but before making a commit, you can run the pre-commit checks with:</p> <pre><code>pre-commit run\n</code></pre> <p>This will go through the staged files, check that all the changed code adheres to the style guidelines, and auto-format the code where necessary. If all the tests pass, you can commit the changes.</p>"},{"location":"#running-tests","title":"Running Tests","text":"<p>Leopard-EM uses the <code>pytest</code> package for running tests. To run the tests, simply run the following command from the root directory of the repository:</p> <pre><code>pytest\n</code></pre> <p>Note that we are still working on expanding the unit tests to cover more of the package, but we ask that any new code contributions include tests where appropriate.</p>"},{"location":"#building-documentation","title":"Building Documentation","text":"<p>The documentation for Leopard-EM is built using MkDocs and Material for MkDocs for generating the documentation site. If you've installed the package with the optional <code>docs</code> dependencies, you can build the documentation site with the following command:</p> <pre><code>mkdocs build\nmkdocs serve\n</code></pre> <p>The first command will construct the HTML files for the documentation site, and the second command will start a local server (at <code>127.0.0.1:8000</code>) to view the site.</p>"},{"location":"#license","title":"License","text":"<p>The code in this repository is licensed under the BSD 3-Clause License. See the LICENSE file for full details.</p>"},{"location":"#references","title":"References","text":"<ol> <li> <p>Lucas BA, Himes BA, Xue L, Grant T, Mahamid J, Grigorieff N. Locating macromolecular assemblies in cells by 2D template matching with cisTEM. Elife. 2021 Jun 11;10:e68946. doi: 10.7554/eLife.68946. PMID: 34114559; PMCID: PMC8219381.\u00a0\u21a9</p> </li> </ol>"},{"location":"data_formats/","title":"Description of Data Formats","text":"<p>To increase interoperability between external packages, we herein describe the different data formats used as input to and export from programs. Orientations on a per-particle bases are currently stored as Euler angles in ZYZ format with angles ordered as . Note that the package is still under development and the exact way the data is represented might change in the future.</p>"},{"location":"data_formats/#data-from-the-match-template-program","title":"Data from the match template program","text":"<p>The match template program collates statistics from a large number of cross-correlograms taken over an orientation and defocus search space. See the API on the <code>MatchTemplateResult</code> object for further information on how these data are stored, but here we provide an overview of what files get written to disk.</p>"},{"location":"data_formats/#best-statistic-maps","title":"Best statistic maps","text":"<p>Each of the \"best\" statistics is stored on a per-position basis in what we dub \"statistics maps\" saved as <code>.mrc</code> files. We have the following tracked statistics for each valid (x, y) position:</p> <ul> <li>Maximum Intensity Projection (MIP): Maximum cross-correlation value over the entire search space.</li> <li>Scaled MIP (z-score): The MIP value normalized by the mean and variance of the cross-correlation over the entire search space.</li> <li>Correlation Mean: The mean of the cross-correlation values over the entire search space. Used to calculate the scaled MIP.</li> <li>Correlation Variance: The variance of the cross-correlation values over the entire search space. Used to calculate the scaled MIP.</li> <li>Phi: The  angle (in degrees) which produced the MIP value.</li> <li>Theta: The  angle (in degrees) which produced the MIP value.</li> <li>Psi: The  angle (in degrees) which produced the MIP value.</li> <li>Defocus: The relative defocus value (in Angstroms, relative to estimated defocus of micrograph) which produced the MIP value.</li> </ul> <p>Each of these statistics maps are saved to disk in the MRC format based on paths provided in the <code>MatchTemplateResult</code> object.</p>"},{"location":"data_formats/#a-note-on-correlation-modes-and-output-shapes","title":"A note on correlation modes and output shapes","text":"<p>Three general modes for convolution/correlation exist in digital signal processing: \"full\", \"same\", and \"valid\". This chapter of Digital Signals Theory provides a good overview of these modes.</p> <p>We use the the \"valid\" mode by default when saving these statistics maps, but they are initially stored in their \"same\" modes. The <code>MatchTemplateResult.apply_valid_cropping</code> method does this \"same\" to \"valid\" cropping. For an image with shape  and template , the modes will output statistics maps with the following shapes:</p> <ul> <li>same:  </li> <li>valid:  </li> </ul> <p>Note that same mode pads the image with zeros along the edges and does not increase the number of particles detectable; values along the padded portions of the edge do not hold significance in the context of the particle detection. In each case, the position in the map at  corresponds to the top-left corner of the template at that position, not the center of the template.</p>"},{"location":"data_formats/#match-template-dataframe","title":"Match template DataFrame","text":"<p>Since not all positions  contain a particle from the match template search, using full statistics maps for downstream analysis can be inefficient in terms of speed, memory requirements, and code overhead. The match template manager class has the method <code>MatchTemplateManager.results_to_dataframe()</code> which automatically picks peaks within the scaled MIP map and stores the peak locations, orientations, and defocus values in a pandas DataFrame. We take a verbose approach to constructing this DataFrame where some columns store similar information about each particle.</p> <p>Additional columns besides locations and orientations are included in the DataFrame to increase the utility of the data, namely the construction of <code>ParticleStack</code> objects. The columns and corresponding descriptions are as follows:</p> Column Name Type Description <code>mip</code> float Maximum cross-correlation value over all search orientations and relative defocus values. <code>scaled_mip</code> float Scaled MIP value (z-score) normalized by cross-correlation mean and variance. <code>correlation_mean</code> float Mean of the cross-correlation values over the entire search space. <code>correlation_variance</code> float Variance of the cross-correlation values over the entire search space. <code>total_correlations</code> int Total number of cross-correlations taken over the search space (defoci times orientations). <code>pos_x</code> int Particle x position (units of pixels) in the statistics maps. Corresponds to the top-left corner of the template. <code>pos_y</code> int Particle y position (units of pixels) in the statistics maps. Corresponds to the top-left corner of the template. <code>pos_x_img</code> int Center of of the particle (x position, units of pixels) in the micrograph. <code>pos_y_img</code> int Center of of the particle (y position, units of pixels) in the micrograph. <code>pos_x_img_angstrom</code> float Center of the particle (x position, in Angstroms) in the micrograph. <code>pos_y_img_angstrom</code> float Center of the particle (y position, in Angstroms) in the micrograph. <code>psi</code> float The  angle (in degrees) which produced the MIP value. <code>theta</code> float The  angle (in degrees) which produced the MIP value. <code>phi</code> float The  angle which (in degrees) produced the MIP value. <code>relative_defocus</code> float The relative defocus value (in Angstroms) which produced the MIP value. Relative to <code>defocus_u</code> and <code>defocus_v</code>. <code>defocus_u</code> float Defocus value along the major axis for the micrograph (in Angstroms). <code>defocus_v</code> float Defocus value along the minor axis for the micrograph (in Angstroms). <code>astigmatism_angle</code> float Angle of the astigmatism (in degrees) for defocus. <code>pixel_size</code> float Pixel size of the micrograph (in Angstroms). <code>voltage</code> float Voltage of the microscope (in kV). <code>spherical_aberration</code> float Spherical aberration of the microscope (in mm). <code>amplitude_contrast_ratio</code> float Amplitude contrast ratio of the microscope. <code>phase_shift</code> float Phase shift of the microscope (in degrees). <code>ctf_B_factor</code> float B-factor of the CTF, in Angstroms^2. <code>micrograph_path</code> str Path to the original micrograph. <code>template_path</code> str Path to the template used for the search. <code>mip_path</code> str Path to the saved MIP map. <code>scaled_mip_path</code> str Path to the saved scaled MIP map. <code>psi_path</code> str Path to the saved psi map. <code>theta_path</code> str Path to the saved theta map. <code>phi_path</code> str Path to the saved phi map. <code>defocus_path</code> str Path to the saved defocus map. <code>correlation_average_path</code> str Path to the saved correlation mean map. <code>correlation_variance_path</code> str Path to the saved correlation variance map."},{"location":"data_formats/#data-from-the-refine-template-program","title":"Data from the refine template program","text":"<p>The refine template program takes in the DataFrame from the match template program and refines the orientation &amp; defocus values of each particle. Each of the refined parameters are stored in new columns prefixed with the <code>refined_</code> string. Note that refined results can be re-refined, for example with a slightly different template, and the already refined parameters will be used.</p>"},{"location":"data_formats/#refine-template-dataframe","title":"Refine template DataFrame","text":"<p>The program outputs another DataFrame with additional columns for the refined orientations, defocus values, and positions. New columns with descriptions are listed below:</p> Column Name Type Description <code>refined_mip</code> float New maximum cross-correlation over refinement search space. <code>refined_scaled_mip</code> float New scaled MIP value (z-score) normalized by cross-correlation mean and variance. <code>refined_pos_x</code> int The refined x position of the particle, top-left corner of the template. <code>refined_pos_y</code> int The refined y position of the particle, top-left corner of the template. <code>refined_pos_x_img</code> int The refined x position of the particle, center of the particle in the micrograph. <code>refined_pos_y_img</code> int The refined y position of the particle, center of the particle in the micrograph. <code>refined_pos_x_img_angstrom</code> float The refined x position of the particle, center of the particle in the micrograph (in Angstroms). <code>refined_pos_y_img_angstrom</code> float The refined y position of the particle, center of the particle in the micrograph (in Angstroms). <code>refined_psi</code> float The refined  angle (in degrees). <code>refined_theta</code> float The refined  angle (in degrees). <code>refined_phi</code> float The refined  angle (in degrees). <code>refined_relative_defocus</code> float The refined relative defocus value (in Angstroms)."},{"location":"examples/basic_configuration/","title":"Template Matching Configurations","text":"In\u00a0[1]: Copied! <pre>from pprint import pprint\n\nfrom leopard_em.pydantic_models import (\n    ArbitraryCurveFilterConfig,\n    BandpassFilterConfig,\n    ComputationalConfig,\n    DefocusSearchConfig,\n    MatchTemplateManager,\n    MatchTemplateResult,\n    OpticsGroup,\n    OrientationSearchConfig,\n    PhaseRandomizationFilterConfig,\n    PreprocessingFilters,\n    WhiteningFilterConfig,\n)\n</pre> from pprint import pprint  from leopard_em.pydantic_models import (     ArbitraryCurveFilterConfig,     BandpassFilterConfig,     ComputationalConfig,     DefocusSearchConfig,     MatchTemplateManager,     MatchTemplateResult,     OpticsGroup,     OrientationSearchConfig,     PhaseRandomizationFilterConfig,     PreprocessingFilters,     WhiteningFilterConfig, ) In\u00a0[2]: Copied! <pre>my_optics_group = OpticsGroup(\n    label=\"my_optics_group\",\n    pixel_size=1.06,\n    voltage=300.0,\n    spherical_aberration=2.7,  # default value\n    amplitude_contrast_ratio=0.07,  # default value\n    phase_shift=0.0,  # default value\n    defocus_u=5200.0,\n    defocus_v=4950.0,\n    astigmatism_angle=25.0,\n    ctf_B_factor=60.0,\n)\n</pre> my_optics_group = OpticsGroup(     label=\"my_optics_group\",     pixel_size=1.06,     voltage=300.0,     spherical_aberration=2.7,  # default value     amplitude_contrast_ratio=0.07,  # default value     phase_shift=0.0,  # default value     defocus_u=5200.0,     defocus_v=4950.0,     astigmatism_angle=25.0,     ctf_B_factor=60.0, ) <p>The Python variable <code>my_optics_group</code> is now an instance of the <code>OpticsGroup</code> model. Note that the model does do validation under-the-hood to ensure necessary fields are present and valid. Any invalid fields will raise a <code>ValidationError</code> when the model is created. Uncomment the following code block to see this in action.</p> In\u00a0[3]: Copied! <pre># bad_optics_group = OpticsGroup(\n#     label=\"bad_optics_group\",\n#     pixel_size=-1.0,  # &lt;--- Must be positive\n#     voltage=300.0,\n#     phase_shift=0.0,  # default value\n#     defocus_u=5200.0,\n#     defocus_v=4950.0,\n#     astigmatism_angle=25.0,\n# )\n</pre> # bad_optics_group = OpticsGroup( #     label=\"bad_optics_group\", #     pixel_size=-1.0,  # &lt;--- Must be positive #     voltage=300.0, #     phase_shift=0.0,  # default value #     defocus_u=5200.0, #     defocus_v=4950.0, #     astigmatism_angle=25.0, # ) In\u00a0[4]: Copied! <pre>optics_dict = my_optics_group.model_dump()\npprint(optics_dict)\n</pre> optics_dict = my_optics_group.model_dump() pprint(optics_dict) <pre>{'amplitude_contrast_ratio': 0.07,\n 'astigmatism_angle': 25.0,\n 'beam_tilt_x': None,\n 'beam_tilt_y': None,\n 'chromatic_aberration': 0.0,\n 'ctf_B_factor': 60.0,\n 'defocus_u': 5200.0,\n 'defocus_v': 4950.0,\n 'even_zernike': None,\n 'label': 'my_optics_group',\n 'mtf_reference': None,\n 'mtf_values': None,\n 'odd_zernike': None,\n 'phase_shift': 0.0,\n 'pixel_size': 1.06,\n 'spherical_aberration': 2.7,\n 'voltage': 300.0,\n 'zernike_moments': None}\n</pre> In\u00a0[5]: Copied! <pre>yaml_filepath = \"./optics_group_example.yaml\"\nmy_optics_group.to_yaml(yaml_filepath)\n</pre> yaml_filepath = \"./optics_group_example.yaml\" my_optics_group.to_yaml(yaml_filepath) <p>A new file called <code>optics_group_example.yaml</code> should now exist in the current working directory with the following contents:</p> <pre>amplitude_contrast_ratio: 0.07\nbeam_tilt_x: null\nbeam_tilt_y: null\nchromatic_aberration: 0.0\nctf_B_factor: 60.0\nastigmatism_angle: 25.0\ndefocus_u: 5200.0\ndefocus_v: 4950.0\neven_zernike: null\nlabel: my_optics_group\nmtf_reference: null\nmtf_values: null\nodd_zernike: null\nphase_shift: 0.0\npixel_size: 1.06\nspherical_aberration: 2.7\nvoltage: 300.0\nzernike_moments: null\n</pre> In\u00a0[6]: Copied! <pre>new_optics_group = OpticsGroup.from_yaml(yaml_filepath)\n\n# Check if the two OpticsGroup objects are equal\nif new_optics_group == my_optics_group:\n    print(\"OpticsGroup objects are equal.\")\nelse:\n    print(\"The two OpticsGroup are not equal!!!\")\n</pre> new_optics_group = OpticsGroup.from_yaml(yaml_filepath)  # Check if the two OpticsGroup objects are equal if new_optics_group == my_optics_group:     print(\"OpticsGroup objects are equal.\") else:     print(\"The two OpticsGroup are not equal!!!\") <pre>OpticsGroup objects are equal.\n</pre> <p>Now that we've covered the basics of creating, serializing, and deserializing the <code>OpticsGroup</code> model, we can move onto the next models without covering the (de)serialization and import/export steps in detail.</p> <p>Below, we create a new instance of the <code>OrientationSearchConfig</code> model with only the <code>in_plane_step</code> and <code>out_of_plane_step</code> attributes set to non-default values.</p> In\u00a0[7]: Copied! <pre>orientation_search_config = OrientationSearchConfig(\n    in_plane_step=4.0,\n    out_of_plane_step=4.0,\n)\n\n# print the model dictionary\norientation_search_config.model_dump()\n</pre> orientation_search_config = OrientationSearchConfig(     in_plane_step=4.0,     out_of_plane_step=4.0, )  # print the model dictionary orientation_search_config.model_dump() Out[7]: <pre>{'in_plane_step': 4.0,\n 'out_of_plane_step': 4.0,\n 'psi_min': 0.0,\n 'psi_max': 360.0,\n 'theta_min': 0.0,\n 'theta_max': 180.0,\n 'phi_min': 0.0,\n 'phi_max': 360.0,\n 'base_grid_method': 'uniform',\n 'symmetry': 'C1'}</pre> In\u00a0[8]: Copied! <pre># Searches defocus between -600 and 600 with a step of 200 Angstroms\ndefocus_search_config = DefocusSearchConfig(\n    enabled=True, defocus_min=-600, defocus_max=600, defocus_step=200\n)\n</pre> # Searches defocus between -600 and 600 with a step of 200 Angstroms defocus_search_config = DefocusSearchConfig(     enabled=True, defocus_min=-600, defocus_max=600, defocus_step=200 ) In\u00a0[9]: Copied! <pre>defocus_search_config.defocus_values\n</pre> defocus_search_config.defocus_values Out[9]: <pre>tensor([-600., -400., -200.,    0.,  200.,  400.,  600.])</pre> In\u00a0[10]: Copied! <pre>whitening_filter_config = WhiteningFilterConfig()\n</pre> whitening_filter_config = WhiteningFilterConfig() In\u00a0[11]: Copied! <pre>bandpass_filter_config = BandpassFilterConfig()\n</pre> bandpass_filter_config = BandpassFilterConfig() In\u00a0[12]: Copied! <pre>phase_randomization_filter = PhaseRandomizationFilterConfig()\n</pre> phase_randomization_filter = PhaseRandomizationFilterConfig() In\u00a0[13]: Copied! <pre>arbitrary_curve_filter = ArbitraryCurveFilterConfig()\n</pre> arbitrary_curve_filter = ArbitraryCurveFilterConfig() In\u00a0[14]: Copied! <pre>preprocessing_filters = PreprocessingFilters(\n    whitening_filter=whitening_filter_config,\n    bandpass_filter=bandpass_filter_config,\n    phase_randomization_filter=phase_randomization_filter,\n    arbitrary_curve_filter=arbitrary_curve_filter,\n)\n</pre> preprocessing_filters = PreprocessingFilters(     whitening_filter=whitening_filter_config,     bandpass_filter=bandpass_filter_config,     phase_randomization_filter=phase_randomization_filter,     arbitrary_curve_filter=arbitrary_curve_filter, ) In\u00a0[15]: Copied! <pre>comp_config = ComputationalConfig()\ncomp_config\n</pre> comp_config = ComputationalConfig() comp_config Out[15]: <pre>ComputationalConfig(gpu_ids=[0], num_cpus=1)</pre> In\u00a0[16]: Copied! <pre>match_template_result = MatchTemplateResult(\n    allow_file_overwrite=True,\n    mip_path=\"./output_mip.mrc\",\n    scaled_mip_path=\"./output_scaled_mip.mrc\",\n    correlation_average_path=\"./output_correlation_average.mrc\",\n    correlation_variance_path=\"./output_correlation_variance.mrc\",\n    orientation_psi_path=\"./output_orientation_psi.mrc\",\n    orientation_theta_path=\"./output_orientation_theta.mrc\",\n    orientation_phi_path=\"./output_orientation_phi.mrc\",\n    relative_defocus_path=\"./output_relative_defocus.mrc\",\n)\n</pre> match_template_result = MatchTemplateResult(     allow_file_overwrite=True,     mip_path=\"./output_mip.mrc\",     scaled_mip_path=\"./output_scaled_mip.mrc\",     correlation_average_path=\"./output_correlation_average.mrc\",     correlation_variance_path=\"./output_correlation_variance.mrc\",     orientation_psi_path=\"./output_orientation_psi.mrc\",     orientation_theta_path=\"./output_orientation_theta.mrc\",     orientation_phi_path=\"./output_orientation_phi.mrc\",     relative_defocus_path=\"./output_relative_defocus.mrc\", ) In\u00a0[17]: Copied! <pre>match_template_manager = MatchTemplateManager(\n    micrograph_path=\"./dummy_micrograph.mrc\",\n    template_volume_path=\"./dummy_template_volume.mrc\",\n    optics_group=my_optics_group,\n    defocus_search_config=defocus_search_config,\n    orientation_search_config=orientation_search_config,\n    preprocessing_filters=preprocessing_filters,\n    match_template_result=match_template_result,\n    computational_config=comp_config,\n    preload_mrc_files=False,  # Don't try to read the MRC upon initialization\n)\n</pre> match_template_manager = MatchTemplateManager(     micrograph_path=\"./dummy_micrograph.mrc\",     template_volume_path=\"./dummy_template_volume.mrc\",     optics_group=my_optics_group,     defocus_search_config=defocus_search_config,     orientation_search_config=orientation_search_config,     preprocessing_filters=preprocessing_filters,     match_template_result=match_template_result,     computational_config=comp_config,     preload_mrc_files=False,  # Don't try to read the MRC upon initialization ) In\u00a0[18]: Copied! <pre>match_template_manager.to_yaml(\"./match_template_manager_example.yaml\")\n</pre> match_template_manager.to_yaml(\"./match_template_manager_example.yaml\") In\u00a0[19]: Copied! <pre>new_match_template_manager = MatchTemplateManager.from_yaml(\n    \"./match_template_manager_example.yaml\"\n)\n\nif new_match_template_manager == match_template_manager:\n    print(\"MatchTemplateManager objects are equal.\")\nelse:\n    print(\"The two MatchTemplateManager are not equal!!!\")\n</pre> new_match_template_manager = MatchTemplateManager.from_yaml(     \"./match_template_manager_example.yaml\" )  if new_match_template_manager == match_template_manager:     print(\"MatchTemplateManager objects are equal.\") else:     print(\"The two MatchTemplateManager are not equal!!!\") <pre>MatchTemplateManager objects are equal.\n</pre>"},{"location":"examples/basic_configuration/#template-matching-configurations","title":"Template Matching Configurations\u00b6","text":"<p>This example notebook outlines the steps necessary to generate, save, and load configurations for the <code>match-template</code> program through Python object and <code>yaml</code> files. Here, we focus on how to create and modify these configurations rather than the underlying code for parsing these configurations and running the program.</p> <p>Rationale for using YAML configurations</p> <p>While the <code>Leopard-EM</code> package provides a basic CLI program and an object-oriented Python API for extending template matching into more complex workflows, it is useful to have a human-readable, easily editable, and shareable configuration file because:</p> <ol> <li>It increases reproducibility by keeping a record of exact parameters used for a particular run,</li> <li>It can be quickly modified during development, debugging, and testing without changing underlying code, and</li> <li>It can be replicated across large datasets (e.g. multiple images with similar configurations) for execution on distributed clusters.</li> </ol> <p>We find that storing configurations in a structured file format strikes a good balance between user-friendliness and programmatic control.</p>"},{"location":"examples/basic_configuration/#importing-necessary-classes-and-functions","title":"Importing Necessary Classes and Functions\u00b6","text":"<p>We utilize Pydantic to create Python objects that parse, validate, and serialize configurations. These objects (called Pydantic models) are laid out in a hierarchial structure with a single root \"manager\" model. Below we import all the configuration classes (along with other libraries) we will detail usage of in this notebook.</p>"},{"location":"examples/basic_configuration/#the-opticsgroup-model","title":"The OpticsGroup Model\u00b6","text":"<p>The <code>OpticsGroup</code> model is a container for microscope imaging parameters necessary for calculating filters (e.g. contrast transfer functions). We follow the fields that are defined in RELION's optics group .star file, and the class has the following attributes:</p> <ul> <li><code>label</code>: A unique label for the optics group, usually contains some form of the micrograph name but can be any string.</li> <li><code>pixel_size</code>: Float value representing the pixel size of the image, in Angstroms.</li> <li><code>voltage</code>: The voltage of the microscope, in kV.</li> <li><code>spherical_aberration</code>: The spherical aberration of the microscope, in mm, with the default value of 2.7 mm.</li> <li><code>amplitude_contrast_ratio</code>: The amplitude contrast ratio (unitless) with the default value of 0.07.</li> <li><code>phase_shift</code>: Additional phase shift to apply across the CTF, in degrees, with the default value of 0.0.</li> <li><code>defocus_u</code>: Defocus of the micrograph along the major axis, in Angstroms.</li> <li><code>defocus_v</code>: Defocus of the micrograph along the minor axis, in Angstroms.</li> <li><code>astigmatism_angle</code>: Angle of the defocus astigmatism (relative to the x-axis), in degrees. The default value is 0.0.</li> <li><code>ctf_B_factor</code>: An additional b-factor to apply to the CTF, in Angstroms^2. The default value is 0.0.</li> </ul> <p>There are other unused fields in the class that are not detailed here. See the Pydantic model API documentation for more information.</p>"},{"location":"examples/basic_configuration/#creating-an-instance-of-the-opticsgroup-model","title":"Creating an instance of the OpticsGroup model\u00b6","text":"<p>Below, we create an instance of the <code>OpticsGroup</code> model with some made-up but nevertheless realistic values.</p>"},{"location":"examples/basic_configuration/#serializing-an-instance-of-the-opticsgroup-model","title":"Serializing an instance of the OpticsGroup model\u00b6","text":"<p>Pydantic has built-in functionality, namely the <code>model_dump()</code>, for generating a dictionary of key, value pairs from the model attributes and their values. Below, we create a dictionary from the <code>my_optics_group</code> instance and print it out. Note that extra, unused fields are still included in the dictionary.</p>"},{"location":"examples/basic_configuration/#exporting-configurations-to-a-yaml-file","title":"Exporting configurations to a YAML file\u00b6","text":"<p>YAML files are nothing more than a bunch of key-value pairs in a human-readable format. Like JSON, YAML has parser functions/libraries in most programming languages increasing their interoperability. We adopt the <code>.yaml</code> format (and <code>.json</code> format, but not discussed here) for our configuration files rather than less-common formats specific to a sub-field or program.</p> <p>The <code>OpticsGroup</code> model (and all the other Pydanic models discussed here) have a <code>to_yaml()</code> method that writes the model to a YAML file. Below, we first specify a path and then call the <code>to_yaml()</code> method on the <code>my_optics_group</code> instance to write the model to a file.</p>"},{"location":"examples/basic_configuration/#importing-configurations-from-a-yaml-file","title":"Importing configurations from a YAML file\u00b6","text":"<p>Each model also has the <code>from_yaml()</code> method which can be to instantiate the class from contents in a <code>.yaml</code> file. Below, we are creating a new instance of the <code>OpticsGroup</code> class from the <code>optics_group.yaml</code> file.</p>"},{"location":"examples/basic_configuration/#the-orientationsearchconfig-model","title":"The OrientationSearchConfig Model\u00b6","text":"<p>Two-dimensional template matching necessitates covering SO(3) orientation space to find the \"best\" orientation match for a particle. How points are sampled during the search process is handled by the <code>OrientationSearchConfig</code> model. This model effectively acts as an interface with the torch-so3 package, which provides the underlying functionality for generating uniform grids on SO(3).</p> <p>The class has the following attributes:</p> <ul> <li><code>in_plane_step</code>: The in-plane step size (in units of degrees) with a default value of 1.5 degrees.</li> <li><code>out_of_plane_step</code>: The out-of-plane step size (in units of degrees) with a default value of 2.5 degrees.</li> <li><code>phi_min</code>: The minimum value for the $\\phi$ Euler angle (in degrees) with a default value of 0.0.</li> <li><code>phi_max</code>: The maximum value for the $\\phi$ Euler angle (in degrees) with a default value of 360.0.</li> <li><code>theta_min</code>: The minimum value for the $\\theta$ Euler angle (in degrees) with a default value of 0.0.</li> <li><code>theta_max</code>: The maximum value for the $\\theta$ Euler angle (in degrees) with a default value of 180.0.</li> <li><code>psi_min</code>: The minimum value for the $\\psi$ Euler angle (in degrees) with a default value of 0.0.</li> <li><code>psi_max</code>: The maximum value for the $\\psi$ Euler angle (in degrees) with a default value of 360.0.</li> <li><code>base_grid_method</code>: The method used to generate the base S2 grid. Allowed values are <code>\"uniform\"</code> and <code>\"healpix\"</code>. The default value is <code>\"uniform\"</code>.</li> </ul> <p>Note that the default min/max values set the search space to cover SO(3) for a particle with <code>\"C1\"</code> symmetry.</p>"},{"location":"examples/basic_configuration/#the-defocussearchconfig-model","title":"The DefocusSearchConfig Model\u00b6","text":"<p>Two-dimensional template matching is also sensitive to the relative defocus of a particle allowing the estimation of the Z-height in a sample. The <code>DefocusSearchConfig</code> model handles which defocus planes are searched over (relative to the defocus parameters defined in the <code>OpticsGroup</code> model).</p> <p>The model has the following attributes:</p> <ul> <li><code>enabled</code>: A boolean value indicating whether defocus search is enabled. The default value is <code>True</code>. If <code>False</code>, then only the defocus value defined in the <code>OpticsGroup</code> model is used.</li> <li><code>defocus_min</code>: The minimum relative defocus value (in Angstroms) to search.</li> <li><code>defocus_max</code>: The maximum relative defocus value (in Angstroms) to search.</li> <li><code>defocus_step</code>: The increment between searched defocus planes (in Angstroms).</li> </ul> <p>These parameters will generate a set of relative defocus planes searched over according to $$[\\text{f}_\\text{min}, \\text{f}_\\text{min} + \\Delta\\text{f}, + \\text{f}_\\text{min} + 2\\Delta\\text{f}, \\dots, \\text{f}_\\text{max}]$$ which is effectively the following range object in Python:</p> <pre>range(defocus_min, defocus_max + defocus_step, defocus_step)\n</pre>"},{"location":"examples/basic_configuration/#the-defocussearchconfigdefocus_values-property","title":"The <code>DefocusSearchConfig.defocus_values</code> property\u00b6","text":"<p>Once a <code>DefocusSearchConfig</code> model is instantiated, there is the helpful <code>defocus_values</code> property that returns a list of relative defocus values to search over.</p>"},{"location":"examples/basic_configuration/#fourier-filters-in-the-preprocessingfilters-model","title":"Fourier filters in the PreprocessingFilters Model\u00b6","text":"<p>Template matching necessitates the use of Fourier filters to preprocess the input image (e.g. spectral whitening). The <code>PreprocessingFilters</code> model handles the configuration of the following filter types:</p> <ul> <li>Spectral whitening under the <code>whitening_filter</code> attribute</li> <li>Bandpass filtering, with the option for smooth transitions, under the <code>bandpass_filter</code> attribute.</li> <li>Phase randomization above a certain frequency using the <code>phase_randomization_filter</code> attribute.</li> <li>Options for a user-defined arbitrary curve filter under the <code>arbitrary_curve_filter</code> attribute.</li> </ul> <p>Together, all these filter types allow fine control over how an input image is preprocessed before template matching. Each filter type is itself a Pydantic model with its own set of attributes.</p>"},{"location":"examples/basic_configuration/#whiteningfilterconfig","title":"WhiteningFilterConfig\u00b6","text":"<p>The <code>WhiteningFilterConfig</code> model handles the configuration of the spectral whitening filter. When applied the image, the power spectral density should become flat and the noise distribution is white (i.e. uncorrelated).</p> <p>The whitening filter is enabled by default and has the following attributes:</p> <ul> <li><code>enabled</code>: A boolean value indicating whether the whitening filter is enabled.</li> <li><code>num_freq_bins</code>: An optional integer specifying the number of frequency bins used when calculating the power spectral density. This parameter is automatically calculated based on the input image size if not provided.</li> <li><code>max_freq</code>: An optional float specifying the maximum spatial frequency (in terms of Nyquist) to use when calculating the whitening filter. Frequencies above this value are set to <code>1.0</code>, that is, unscaled. The default value is <code>0.5</code> which corresponds to the Nyquist frequency.</li> <li><code>do_power_spectrum</code>: Boolean indicating weather the whitening filter should be calculated over the power spectrum or amplitude spectrum. The default value is <code>True</code> and the power spectrum is used.</li> </ul> <p>Below, we create a default instance of the <code>WhiteningFilterConfig</code> model.</p>"},{"location":"examples/basic_configuration/#bandpassfilterconfig","title":"BandpassFilterConfig\u00b6","text":"<p>The <code>BandpassFilterConfig</code> model handles the configuration of the bandpass filter.</p> <p>The bandpass filter is disabled by default and has the following attributes:</p> <ul> <li><code>enabled</code>: A boolean value indicating whether the bandpass filter is enabled.</li> <li><code>low_freq_cutoff</code>: The low-pass cutoff frequency (in terms of Nyquist) for the bandpass filter.</li> <li><code>high_freq_cutoff</code>: The high-pass cutoff frequency (in terms of Nyquist) for the bandpass filter.</li> <li><code>falloff</code>: The falloff factor (using a cosine function) for the bandpass filter. A value of <code>0.0</code> (default) corresponds to a hard cutoff with values in the range <code>(0.0, 0.1)</code> providing a smooth, but distinct, transition.</li> </ul> <p>When disabled, the bandpass filter is not applied to the input image. Nonetheless, we create a default instance of the <code>BandpassFilterConfig</code> model below.</p>"},{"location":"examples/basic_configuration/#phaserandomizationfilterconfig","title":"PhaseRandomizationFilterConfig\u00b6","text":"<p>The <code>PhaseRandomizationFilterConfig</code> model hold parameters defining a phase randomization filter. This filter keeps the amplitudes of Fourier components above a certain frequency the same, but randomizes their phases. This is useful for testing the robustness of template matching algorithms to noise.</p> <p>The model is disabled by default has the following attributes:</p> <ul> <li><code>enabled</code>: A boolean value indicating whether the phase randomization filter is enabled.</li> <li><code>cuton</code>: The cuton frequency (in terms of Nyquist) for the phase randomization filter. Frequencies above this value are randomized.</li> </ul> <p>Below, we create a default instance of the <code>PhaseRandomizationFilterConfig</code> model.</p>"},{"location":"examples/basic_configuration/#arbitrarycurvefilterconfig","title":"ArbitraryCurveFilterConfig\u00b6","text":"<p>We also provide a model for defining an arbitrary curve filter for preprocessing. This filter takes a set of spatial frequency values (in terms of Nyquist) and filter amplitudes at those frequencies to create a custom filter. Utilizing this filter allows for fine-grained control over how spatial frequencies should be weighted within the template matching package itself.</p> <p>The model is disabled by default has the following attributes:</p> <ul> <li><code>enabled</code>: A boolean value indicating whether the arbitrary curve filter is enabled.</li> <li><code>frequencies</code>: 1-dimensional list of floats representing the spatial frequencies (in terms of Nyquist). The list must be sorted in ascending order.</li> <li><code>amplitudes</code>: 1-dimensional list of floats representing the filter amplitudes at the corresponding frequencies. The list must be the same length as <code>frequencies</code>.</li> </ul> <p>Below, we create a default instance of the <code>ArbitraryCurveFilterConfig</code> mode; it is disabled and has no frequencies or amplitudes set.</p>"},{"location":"examples/basic_configuration/#putting-the-filters-together-in-the-preprocessingfilters-model","title":"Putting the filters together in the PreprocessingFilters Model\u00b6","text":"<p>We now construct the <code>PreprocessingFilters</code> model with the instances of the four filter models we created above.</p>"},{"location":"examples/basic_configuration/#computationalconfig","title":"ComputationalConfig\u00b6","text":"<p>The <code>ComputationalConfig</code> model currently only handles the GPU ids to use for template matching. The model has the following attributes:</p> <ul> <li><code>gpu_ids</code>: A list of integers representing the GPU ids to use for template matching. The default value is <code>[0]</code> which corresponds to the first GPU.</li> </ul> <p>Below, we create a new instance of the <code>ComputationalConfig</code> model with the default GPU id list.</p>"},{"location":"examples/basic_configuration/#specifying-result-output-with-the-matchtemplateresult-model","title":"Specifying result output with the MatchTemplateResult Model\u00b6","text":"<p>We almost have a complete set of configurations for the <code>match-template</code> program, but we still need to specify where to save results after the program completes. The <code>MatchTemplateResult</code> model handles this by specifying output file paths. The model also has handy class methods for analyzing results and picking particles, but this is discussed elsewhere in the documentation.</p>"},{"location":"examples/basic_configuration/#user-definable-attributes","title":"User-definable attributes\u00b6","text":"<p>The model has the following user-definable attributes:</p> <ul> <li><code>allow_file_overwrite</code>: A boolean value indicating whether the program should be allowed to overwrite existing files. The default value is <code>False</code> and will raise an error if a file already exists.</li> <li><code>mip_path</code>: The path to save the maximum intensity projection (MIP) image.</li> <li><code>scaled_mip_path</code>: The path to save the scaled MIP (a.k.a z-score or SNR) image.</li> <li><code>correlation_average_path</code>: The path to save the average correlation value per pixel.</li> <li><code>correlation_variance_path</code>: The path to save the variance of the correlation value per pixel.</li> <li><code>orientation_psi_path</code>: The path to save the best $\\psi$ Euler angle map.</li> <li><code>orientation_theta_path</code>: The path to save the best $\\theta$ Euler angle map.</li> <li><code>orientation_phi_path</code>: The path to save the best $\\phi$ Euler angle map.</li> <li><code>relative_defocus_path</code>: The path to save the best relative defocus map.</li> </ul>"},{"location":"examples/basic_configuration/#attributes-updated-after-template-matching","title":"Attributes updated after template matching\u00b6","text":"<p>There are additional attributes in the model which automatically get updated after template matching is complete:</p> <ul> <li><code>total_projections</code>: The total number of projections (\\text{orientations} \\times \\text{defocus planes}) searched over.</li> <li><code>total_orientations</code>: The total number of orientations searched over.</li> <li><code>total_defocus</code>: The total number of defocus planes searched over.</li> </ul>"},{"location":"examples/basic_configuration/#creating-an-instance-of-the-matchtemplateresult-model","title":"Creating an instance of the MatchTemplateResult model\u00b6","text":"<p>Below, we specify the necessary output paths for the <code>MatchTemplateResult</code> model. Note that this configuration will output the images into thee current working directory. You will need to update these paths to whatever is appropriate for your system.</p>"},{"location":"examples/basic_configuration/#root-matchtemplateconfig-model","title":"Root MatchTemplateConfig Model\u00b6","text":"<p>Finally, we have all the components which go into the root <code>MatchTemplateConfig</code> model. This model is the top-level configuration object that contains all the other models as attributes along with <code>micrograph_path</code> and <code>template_volume_path</code> which point to the input micrograph and simulated reference template volume, respectfully.</p> <p>Below, we create our instance of the <code>MatchTemplateConfig</code> model. Note that you will need to supply the paths to the micrograph and template volume on your system; dummy paths are provided here so the code runs without error.</p>"},{"location":"examples/basic_configuration/#serializing-the-matchtemplateconfig-model","title":"Serializing the MatchTemplateConfig model\u00b6","text":"<p>Like discussed before, we can serialize and read the <code>MatchTemplateConfig</code> model to/from a YAML file. Below, we write the model to a file called <code>match_template_example.yaml</code>.</p>"},{"location":"examples/basic_configuration/#importing-the-matchtemplateconfig-model-from-a-yaml-file","title":"Importing the MatchTemplateConfig model from a YAML file\u00b6","text":"<p>Now, we re-import the configuration into a new model and check that they are the same.</p>"},{"location":"examples/basic_configuration/#conclusion","title":"Conclusion\u00b6","text":"<p>We have now covered the creation, serialization, and deserialization of all the configuration models necessary for the <code>match-template</code> program. This script will create the <code>match_template_example.yaml</code> file in the current working directory whose file contents should match what is listed below. Modifying this file and using it as input to the <code>match-template</code> program will allow you to run the program with the specified configurations. Note that a default YAML configuration can also be found in the GitHub page.</p> <pre>computational_config:\n  gpu_ids:\n  - 0\n  num_cpus: 1\ndefocus_search_config:\n  defocus_max: 600.0\n  defocus_min: -600.0\n  defocus_step: 200.0\n  enabled: true\nmatch_template_result:\n  allow_file_overwrite: true\n  correlation_average_path: ./output_correlation_average.mrc\n  correlation_variance_path: ./output_correlation_variance.mrc\n  mip_path: ./output_mip.mrc\n  orientation_phi_path: ./output_orientation_phi.mrc\n  orientation_psi_path: ./output_orientation_psi.mrc\n  orientation_theta_path: ./output_orientation_theta.mrc\n  relative_defocus_path: ./output_relative_defocus.mrc\n  scaled_mip_path: ./output_scaled_mip.mrc\n  total_defocus: 0\n  total_orientations: 0\n  total_projections: 0\nmicrograph_path: ./dummy_micrograph.mrc\noptics_group:\n  amplitude_contrast_ratio: 0.07\n  beam_tilt_x: null\n  beam_tilt_y: null\n  chromatic_aberration: 0.0\n  ctf_B_factor: 60.0\n  astigmatism_angle: 25.0\n  defocus_u: 5200.0\n  defocus_v: 4950.0\n  even_zernike: null\n  label: my_optics_group\n  mtf_reference: null\n  mtf_values: null\n  odd_zernike: null\n  phase_shift: 0.0\n  pixel_size: 1.06\n  spherical_aberration: 2.7\n  voltage: 300.0\n  zernike_moments: null\norientation_search_config:\n  base_grid_method: uniform\n  in_plane_step: 4.0\n  out_of_plane_step: 4.0\n  phi_max: 360.0\n  phi_min: 0.0\n  psi_max: 360.0\n  psi_min: 0.0\n  theta_max: 180.0\n  theta_min: 0.0\npreprocessing_filters:\n  arbitrary_curve_filter:\n    amplitudes: null\n    enabled: false\n    frequencies: null\n  bandpass_filter:\n    enabled: false\n    falloff: null\n    high_freq_cutoff: null\n    low_freq_cutoff: null\n  phase_randomization_filter:\n    cuton: null\n    enabled: false\n  whitening_filter:\n    do_power_spectrum: true\n    enabled: true\n    max_freq: 0.5\n    num_freq_bins: null\ntemplate_volume_path: ./dummy_template_volume.mrc\n</pre>"},{"location":"programs/match_template/","title":"The match template program","text":"<p>The match template program takes in a micrograph and a simulated reference structure along with search parameters to find locations in the image which agree with expected 2D projections of this reference structure. Notably, the match template program simultaneously find the orientations of these particles as well as the depth of the particle within the sample.</p>"},{"location":"programs/match_template/#configuration-options","title":"Configuration options","text":"<p>A default config file for the match template program is available here on the GitHub page. This file is separated into multiple \"blocks\" each configuring distinct portions of the program discussed briefly below. Defining and exporting these configurations in terms of Python objects is detailed in Match Template Configuration</p>"},{"location":"programs/match_template/#top-level-micrograph-and-template-paths","title":"Top-level micrograph and template paths","text":"<p>The first two fields in the configuration are paths to the 3D reference template and 2D micrograph saved as MRC files. Update these paths based on your system/experiment.</p> <pre><code>template_volume_path: /some/path/to/template.mrc\nmicrograph_path:      /some/path/to/micrograph.mrc\n</code></pre> <p>Note the reference template should be simulated under the same conditions as the experimental micrograph (e.g. total exposure). A 3D volume can be simulated from a PDB structure using the TeamTomo ttsim3d Python package.</p>"},{"location":"programs/match_template/#output-result-files","title":"Output result files","text":"<p>The next block is the <code>match_template_result</code> configuration which defined the output paths for the match template program results. Note that these paths need to be writable by the user executing the program, and the <code>match_template_result</code> needs to be set to <code>true</code> if you are overwriting pre-existing result files.</p> <pre><code>match_template_result:\n  allow_file_overwrite: true\n  mip_path:                   /some/path/to/output_mip.mrc\n  scaled_mip_path:            /some/path/to/output_scaled_mip.mrc\n  orientation_psi_path:       /some/path/to/output_orientation_psi.mrc\n  orientation_theta_path:     /some/path/to/output_orientation_theta.mrc\n  orientation_phi_path:       /some/path/to/output_orientation_phi.mrc\n  relative_defocus_path:      /some/path/to/output_relative_defocus.mrc\n  correlation_average_path:   /some/path/to/output_correlation_average.mrc\n  correlation_variance_path:  /some/path/to/output_correlation_variance.mrc\n</code></pre> <p>Results are saved as MRC files with positions  corresponding to positions in the image. See Data Formats for more information.</p>"},{"location":"programs/match_template/#optics-group-for-micrograph-parameters","title":"Optics group for micrograph parameters","text":"<p>Constructing the projective filters requires knowledge of what microscope parameters were used to collect the micrograph, namely the defocus of the image. These microscope parameters are collected under the <code>optics_group</code> block with the most common parameters listed below.</p> <pre><code>optics_group:\n  label: some_label\n  voltage: 300.0\n  pixel_size: 1.06   # in Angstroms\n  defocus_u: 5200.0  # in Angstroms\n  defocus_v: 4950.0  # in Angstroms\n  astigmatism_angle: 25.0  # in degrees\n  spherical_aberration: 2.7  # in millimeters\n  amplitude_contrast_ratio: 0.07\n  ctf_B_factor: 60.0  # in Angstroms^2\n</code></pre> <p>Note the <code>label</code> field is currently unused, but could be integrated in the future to differentiate between multiple micrographs and/or refined optical parameters.</p>"},{"location":"programs/match_template/#defocus-search-space-configuration","title":"Defocus search space configuration","text":"<p>Defining the defocus search space is configured using the <code>defocus_search_config</code> block which defines the minimum, maximum, and step size of defocus values searched over in units of Angstroms.</p> <pre><code>defocus_search_config:\n  defocus_max:  1200.0  # in Angstroms, relative to the defocus_u and defocus_v values\n  defocus_min: -1200.0  # in Angstroms, relative to the defocus_u and defocus_v values\n  defocus_step: 200.0   # in Angstroms\n  enabled: true\n</code></pre> <p>Note that these defocus values are relative to <code>optics_group.defocus_u</code> and <code>optics_group.defocus_v</code> values. Also, the defocus search can be turned off by changing <code>enabled: true</code> to <code>enabled: false</code>.</p>"},{"location":"programs/match_template/#orientation-search-space-configuration","title":"Orientation search space configuration","text":"<p>Defining the orientation search space is configured using the <code>orientation_search_config</code> block which defines the orientation sampling parameters. We find that an in-plane step size of 1.5 degrees and out-of-plane step size of 2.5 degrees with a uniform base grid works well when searching for ribosomes, but other sized structures may need these parameters adjusted. There is also the <code>\"heapix\"</code> option for the <code>base_grid_method</code> field which uses the HEALPix discretization of the sphere to sample orientation space. Also, the underlying torch-so3 package supports multiple particles symmetries but we are working to port that into the Leopard-EM package; currently only C1 symmetry is used.</p> <pre><code>orientation_search_config:\n  base_grid_method: uniform\n  in_plane_step: 1.5      # in degrees\n  out_of_plane_step: 2.5  # in degrees\n\n</code></pre>"},{"location":"programs/match_template/#configuring-the-pre-processing-filters","title":"Configuring the pre-processing filters","text":"<p>We also include some configuration options for pre-processing Fourier filters applied to both the image and template. Below, we briefly discuss the parameter choices for the whitening and band-pass filters -- the two most common filter types; there are two additional pre-processing filters (phase-randomization and arbitrary curve) discussed here. In most cases, the default values should suffice, but nevertheless the knobs to tweak how calculations are performed are included for completeness' sake.</p> <p>The whitening filter, with parameters defined under <code>preprocessing_filters.whitening_filter</code>, flattens the 1D power spectrum of the image so each frequency component contributes equally to the cross-corelation; the same filter is applied to template projections. The whitening filter is enabled by default and necessary to compensate for the the strong low-frequency components of in situ cryo-EM images,<sup>1</sup> but the filter can be disabled by changing <code>enabled: true</code> to <code>enabled: false</code>. Changing the <code>do_power_spectrum</code> to <code>false</code> will calculate the whitening filter based on the amplitude spectrum instead of the power spectrum. The <code>whitening_filter.max_freq</code> field defines the maximum frequency considered (in terms of Nyquist) when calculating the whitening filter; the default of <code>0.5</code> should perform well in most cases. Similarly, keeping the default <code>num_freq_bins: null</code> will choose the number of frequency bins automatically based on input image shape. Values between 500-2,000 are generally good.</p> <p>Bandpass filtering is disabled by default but can be turned on by changing <code>enabled: false</code> to <code>enabled: true</code>. Note that the <code>high_freq_cutoff</code> and <code>low_freq_cutoff</code> fields are both defined in terms of the Nyquist frequency with values of <code>null</code> corresponding to no cutoff. For example, <code>high_freq_cutoff: 0.5</code> and <code>low_freq_cutoff: null</code> would correspond to a low-pass filter to the Nyquist frequency of the image. Filtering to a specific resolution in terms of Angstroms means doing some basic math to populate these fields.</p> <pre><code>preprocessing_filters:\n  whitening_filter:\n    enabled: true\n    do_power_spectrum: true\n    max_freq: 0.5  # In terms of Nyquist frequency\n    num_freq_bins: null\n  bandpass_filter:\n    enabled: false\n    falloff: null\n    high_freq_cutoff: null  # Both high/low in terms of Nyquist frequency\n    low_freq_cutoff: null   # e.g. low-pass to 3 \u00c5 @ 1.06 \u00c5/px would be 1.06/3 = 0.353\n</code></pre>"},{"location":"programs/match_template/#configuring-gpus-for-a-match-template-run","title":"Configuring GPUs for a match template run","text":"<p>The final block of the match template configuration file is used to choose which GPUs will run on. The <code>num_cpus</code> field can currently be ignored and just set to <code>1</code>. The <code>gpu_ids</code> field is a list of integers defining which GPU device index(s) the program will target. Configuring the search to be run on the first two GPUs is shown below.</p> <pre><code>computational_config:\n  gpu_ids:\n  - 0\n  - 1\n  num_cpus: 1\n</code></pre>"},{"location":"programs/match_template/#running-the-match-template-program","title":"Running the match template program","text":"<p>Once you've configured a YAML file, running the match template program is fairly simple. We have an example script, <code>src/programs/match_template.py</code>, which processes a single micrograph against a single reference template. Again, you will need to simulate a 3D electron scattering potential from a PDB file (for example with the ttsim3d package) before running the script.</p>"},{"location":"programs/match_template/#match-template-output-files","title":"Match template output files","text":"<p>The above script will output the statistics maps over the image for the search as well as a Pandas DataFrame with compacted information on found particles. These data can be passed onto downstream analysis, for example the refine template program. More detail about these data is on the data formats page.</p>"},{"location":"programs/match_template/#mathematical-description","title":"Mathematical description","text":"<p>Described succinctly using mathematics, the match template constructs the orientational search space, , and relative defocus search space, , to generate the CTF-convolved projections searched over:</p> <p> </p> <p>The \"best\" projection, based on cross-correlation with the cryo-EM image , is found,</p> <p> </p> <p>where the indexes  and  correspond to the orientation and relative defocus which generated the \"best\" projection. Orientations of the best projection are returned as Euler angles  in the ZYZ format. Note that this search is done simultaneous for all positions,   within the image using the convolution theorem, but here we focus on a single location in the image. The match template program also returns the Maximum Intensity Projection (MIP) which is the cross-correlation score of the best projection as well as a z-score on a per-pixel level.</p> <p> </p> <p>There are other steps, namely Fourier filtering, which are discussed further in the theory portion of the documentation.</p> <ol> <li> <p>J Peter Rickgauer, Nikolaus Grigorieff, Winfried Denk (2017) Single-protein detection in crowded molecular environments in cryo-EM images eLife 6:e25648, https://doi.org/10.7554/eLife.25648\u00a0\u21a9</p> </li> </ol>"},{"location":"programs/programs_landing_page/","title":"Programs at a glance","text":"<p>The Leopard-EM package currently has 4 programs that are easily user-configurable and callable. Each of these programs is built from modular components, namely Pydantic models for input/output parsing and Python functions for data processing; building upon these modular components for more complex workflows is both possible and encouraged.</p>"},{"location":"programs/programs_landing_page/#i-want-to","title":"I want to","text":"<ul> <li>find particles in cryo-EM images using a reference template --&gt; <code>match_template</code></li> <li>refine the location, orientations, and defocus values of particles --&gt; <code>refine_template</code></li> <li>search over pixel size for the micrograph using 2DTM z-scores as the metric --&gt; <code>refine_template</code></li> <li>search for similar but slightly different structures using already template matched results --&gt; <code>refine_template</code></li> <li>optimize the pixel size for the reference template using 2DTM z-scores as the metric --&gt; <code>optimize_template</code></li> <li>adjust b-factors added to the template to increase number of identified particles --&gt; <code>optimize_B_factor</code></li> </ul> <p>More details on each of the programs can be found on their respective pages, linked below.</p> <ul> <li>Match Template</li> </ul>"}]}